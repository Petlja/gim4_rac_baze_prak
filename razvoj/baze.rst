Читање података из табеле
=========================

SQL корисницима омогућава да веома једноставно из базе података
извлаче оне податке који су им потребни. То се ради постављањем
**упита**. Основну врсту упита чине тзв. упити ``SELECT`` који служе
да се из базе прочитају жељени подаци. Постоје и друге врсте
упита. Упити ``INSERT`` служе да се у базу упишу нови подаци, упити
``DELETE`` да се из базе обришу неки подаци, а упити ``UPDATE`` да се
неки подаци у бази ажурирају (измене). Упитима се могу и креирати и
брисати табеле, подешавати различита ограничења и слично. У наставку
ћемо се бавити упитима ``SELECT``, док ћемо остале врсте упита
обрадити касније.

Сваки, па и најједноставнији упит ``SELECT`` мора да садржи следеће
елементе:

.. code-block::

   SELECT kolone
   FROM tabele;

Овим се систему налаже да нам из наведене табеле (или више табела)
издвоји све податке који су дати у наведеним колонама. Језик није
осетљив на разлику између великих и малих слова (могуће је писати и
``select`` и ``from``), али ћемо ми у складу са устаљеном праксом, у
наставку све кључне речи писати великим словима. Све белине у упиту се
занемарују, па самим тим није битно да ли се упит пише у једном или
више редова. Прегледности ради, ми ћемо све упите писати у више редова.

За почетак ћемо увек читати податке само из једне
табеле. Најједноставнији случај је онај у коме се жели читање свих
података из једне табеле. Тада се уместо имена свих колона може
навести само симбол ``*``. Размотримо следећи пример.
   
.. class:: question

   Приказати све податке о ученицима који су уписани у бази.

.. code-block:: sql

   SELECT *
   FROM ucenik;

Овај упит може да се прочита као *прочитај све врсте из табеле
ученика*.  Он је еквивалентан следећем, али је, наравно, много
једноставнији.

.. code-block:: sql

   SELECT id, ime, prezime, pol, datum_rodjenja, razred, odeljenje
   FROM ucenik;

Пројекција
----------
   
Наравно, могуће је да издвојимо и само податке из неких колона.

.. class:: question

   Приказати имена и презимена свих ученика.

.. code-block:: sql

   SELECT ime, prezime FROM ucenik;

Овај упит може да се прочита као *прочитај имена и презимена свих
врста из табеле ученика*.
   
У теорији база података операција којом се издвајају само неке колоне
из табеле назива се **пројекција**.

.. class:: question

   Приказати идентификаторе и називе предмета и разреде у којима се ти
   предмети предају.

.. code-block:: sql

   SELECT id, naziv, razred FROM predmet;
   

Рестрикција (WHERE)
-------------------

Као што смо могли да одаберемо само податке из неких колона, тако
можемо да одаберемо и само податке из неких врста, тј. да извршимо
филтрирање података на основу неког задатог услова. Тада је потребно
да користимо следећи облик упита ``SELECT``.

.. code-block::

   SELECT kolone
   FROM tabele
   WHERE uslov;


Кажемо да је извршена **рестрикција** табеле тј. да смо извршили
**филтрирање** података. Пројекцијом, дакле, избацујемо одређене
колоне из резултата, а рестрикцијом одређене врсте. У наставку ћемо
кроз низ погодних примера илустровати различите облике услова које
можемо користити.

.. class:: question

   Приказати све податке о ученицима првог разреда.
   

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE razred = 1;

Овај упит се може протумачити као *прочитај све врсте из табеле ученик
код којих је разред једнак 1*. Услов у овом упиту је ``razred =
1``. Приметимо да се у услову могу наводити називи колона табеле, као
и константне вредности (у овом случају то је број 1), док се за
једнакост користи знак ``=``.

.. class:: question

   Приказати све податке о предметима у другом разреду

.. code-block:: sql

   SELECT *
   FROM predmet
   WHERE razred = 2;


.. class:: question

   Приказати све податке о ученицима који се зову ``Петар``.
   
.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE ime = 'Петар';

У овом упиту услов је ``ime = 'Петар'``. Приметимо да је овај пут
константна вредност ``'Петар'`` наведена под једноструким наводницима,
јер је у питању ниска карактера. Исти ефекат се може добити и ако се
употребе двоструки наводници.

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE ime = "Петар";

.. class:: question

   Приказати све оцене добијене на писменим задацима.

.. code-block:: sql

   SELECT *
   FROM ocena
   WHERE vrsta = 'писмени задатак';


Логички оператори (AND, OR, NOT)
................................

Више логичких услова могуће је повезати уобичајеним логичким операторима:

- Оператор ``AND`` означава конјункцију тј. логичко *и*.
- Оператор ``OR`` означава конјункцију тј. логичко *или*.
- Оператор ``NOT`` означава негацију тј. логичко *не*.

Прикажимо њихову употребу на неколико примера упита.

.. class:: question

   Приказати све податке о ученицима одељења I2 (првог два).
   
.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE razred = 1 AND odeljenje = 2;

Овај упит можемо протумачити као *прочитај све врсте из табеле ученика
код којих је разред једнак 1 и одељење једнако 2*. Приметимо да се у
овом примеру захтева да ученик иде у први разред, као и да иде у друго
одељење (пошто се тражи да су испуњени и први и други услов,
употребљава се оператор ``AND``).


.. class:: question

   Приказати све податке о ученицима који се зову Петар Петровић.

Нагласимо да је могуће да постоји више ученика који имају исто име и презиме.
   
.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE ime = 'Петар' AND prezime = 'Петровић';

Структура овог упита је веома слична оном претходном (потребно је да
су задовољена оба наведена услова).

   
.. class:: question
   
   Приказати све податке о ученицима који иду у непарну смену (то су
   ученици који иду у први и ученици који иду у трећи разред).


.. code-block:: sql
   
   SELECT *
   FROM ucenik
   WHERE razred = 1 OR razred = 3;

Овај упит можемо протумачити као *прочитај све врсте из табеле ученика
код којих је разред једнак 1 или је разред једнак 3*. У овом примеру
је довољно да је задовољен било који од два наведена услова (подаци о
ученику се приказују било да иде у први, било да иде у трећи разред),
па се користи оператор ``OR``.

.. class:: question
   
   На екскурзију у октобру иду сви ученици, осим ученика првог разреда.
   Приказати њихова имена и презимена.

Тражи се списак ученика код којих је разред различит од 1. Задатак
можемо решити применом оператора ``NOT``.

.. code-block:: sql
   
   SELECT *
   FROM ucenik
   WHERE NOT (razred = 1);

Овај упит можемо протумачити као *прочитај све врсте из табеле ученика
код којих није разред једнак 1*. Ипак, још једноставније решење је да
се употреби оператор различито ``!=``.

.. code-block:: sql
   
   SELECT *
   FROM ucenik
   WHERE razred != 1;

   
.. class:: question

   Приказати све податке о ученицима који се презивају ``Петровић``,
   али се не зову ``Петар``.

И у овом случају можемо употребити оператор ``NOT``.

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE NOT (ime = 'Петар') AND prezime = 'Петровић';

или оператор различито.

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE ime != 'Петар' AND prezime = 'Петровић';


Релацијски оператори (<, <=, >, >=, BETWEEN, IN)
................................................

До сада смо у свим упитима употребљавали само релацијске операторе
једнако (``=``) и различито (``!=``). Језик SQL подржава још неке
релацијске операторе. Над бројевима (као и на још неким типовима) се
могу употребљавати и релацијски оператори поретка ``<``, ``<=``, ``>``
и ``>=``.

.. class:: question

   Приказати све ученике старијих разреда


Приказујемо све ученике код којих је разред већи или једнак од 3.
   
.. code-block:: sql
                
   SELECT *
   FROM ucenik
   WHERE razred >= 3;

Овај упит можемо протумачити као *прочитај све врсте из табеле ученика
из којих је разред већи или једнак 3*. Алтернативно, приказујемо све
ученике код којих је разред строго већи од два.
   
.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE razred > 2;


.. class:: question
   
   Приказати све податке о предметима у прва два разреда
   
.. code-block:: sql

   SELECT *
   FROM predmet
   WHERE razred <= 2;
   
Оператори поретка се могу применити и на другим типовима података (на
пример, нискама и датумима).


.. class:: question

   Приказати све податке о учениицма који су рођени после првог јуна 2007.

   
.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE datum_rodjenja > '2007-06-01';

Приметимо да се датум наводи као ниска карактера, између једноструких
наводника, у формату ``gggg-mm-dd``.


.. class:: question

   Приказати све податке о ученицима који су на време кренули у школу током
   2007. године (то су они који су рођени између 1. марта 2007. и 1. марта 
   2008. године, не укључујући последњи датум)

.. code-block:: sql
                
   SELECT *
   FROM ucenik
   WHERE '2007-03-01' <= datum_rodjenja AND datum_rodjenja < '2008-03-01';

Припадност интервалу се може испитивати и помоћу посебног оператора
``BETWEEN ... AND ...``.

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE datum_rodjenja BETWEEN '2007-01-01' AND '2007-12-31';


.. class:: question

Приказати податке о свим регулисаним изостанцима на првом часу
добијеним у 2021. години.

.. code-block:: sql

   SELECT *
   FROM izostanak
   WHERE datum BETWEEN '2021-01-01' AND '2021-12-01' AND
         status != 'нерегулисан' AND cas = 1;

                
.. class:: question

   Приказати све ученике који су у дневнику одељења I1 пре Петровића

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE razred = 1 AND odeljenje = 1 AND prezime < 'Петровић';

У овом упиту смо презиме упоредили са Петровић, помоћу оператора ``<``
и тада се поређење врши по азбучном редоследу (каже се,
лексикографски).

Још један често коришћен оператор који се примењује над текстуалним
подацима (нискама) је оператор ``LIKE`` којим се може наметнути облик
(шаблон) ниске који желимо да издвојимо (или изоставимо) из резултата.

.. class:: question

   Приказати све ученике чије презиме почиње на слово ``П``.

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE prezime LIKE 'П%';

Шаблон презимена која се траже је описан у облику ``'П%'``, што значи
да она почињу словом `П` након чега иде произвољан низ карактера
(карактер ``%`` у склопу шаблона означава било какав низ карактера,
док карактер ``_`` означава било који карактер).
   
.. class:: question

   Приказати све ученике чији су иницијали ``ПП``.
   

.. code-block:: sql

   SELECT *
   FROM ucenik
   WHERE ime LIKE 'П%' AND prezime LIKE 'П%';
   
.. class:: question

Приказати имена и презимена ученика чије се презиме не завршава на ``ић``.

.. code-block:: sql

   SELECT ime, prezime
   FROM ucenik
   WHERE NOT (prezime LIKE '%ић');

У овом примеру је употребљен оператор ``NOT`` да би се приказали само
они ученици чије се презиме НЕ уклапа у дати шаблон. Шаблон ``'%ић'``
означава произвољан низ карактера иза којих иде ниска ``ић``.


.. code-block:: sql

   SELECT ime, prezime
   FROM ucenik
   WHERE NOT (prezime LIKE '%ић');


Још један користан оператор може бити оператор ``IN`` којим се
проверава да ли вредност припада неком датом скупу
елемената. Прикажимо његову употребу на следећем примеру.

.. class:: question
           
   Издвојити податке о свим предметима који се зову ``Математика``,
   ``Физика`` или ``Рачунарство и информатика``.

.. code-block:: sql

   SELECT *
   FROM predmet
   WHERE naziv IN ('Математика', 'Физика', 'Рачунарство и информатика')

Изрази и функције
-----------------

Након ``SELECT`` се најчешће наводе само називи колона, међутим,
могуће је употребити и сложеније изразе који у себи укључују и
вредности прочитане из одговарајућих колона. Тиме заправо
**пресликавамо** вредности прочитане из колона табела применом
одговарајућих функција. Илуструјмо ово кроз неколико примера.

.. class:: question
           
   Приказати годишњи фонд часова за сваки предмет (претпоставља се да
   школска година има 37 радних недеља).

.. code-block:: sql
                
   SELECT naziv, razred, 37 * fond
   FROM predmet;

Уместо назива колоне ``fond`` наведен је израз ``37 * fond`` који
подразумева да се вредност прочитана из колоне фонд помножи са 37.
   
Приметимо да колона са годишњим фондом нема неко илустративно име. То
можемо променити коришћењем тзв. **алијаса** тако што ћемо колони
променити име коришћењем кључне речи ``AS``.
   
.. code-block:: sql
                
   SELECT naziv, razred, 37 * fond AS godisnji_fond
   FROM predmet;

Ниске се могу надовезати оператором ``||``.
   
.. class:: question

   Направити јединствену колону која садржи пуно име и презиме сваког
   ученика.
           
.. code-block:: sql
                
   SELECT id, ime || ' ' || prezime AS ime_i_prezime
   FROM ucenik

Напоменимо да се у неким другим системима за управљање базама података
за надовезивање ниски користи функција ``CONCAT``.


.. class:: question

   Направити преглед регулисаних и нерегулисаних изостанака, тако што
   се уз идентификатор сваког изостанка прикаже да ли је нерегулисан
   или регулисан (било да је оправдан или неоправдан).

Задатак ћемо решити употребом гранања. Основни облик гранања у језику
SQL је израз ``CASE``. Његова основна синтакса је облика:

.. code-block::

   CASE
      WHEN uslov1 THEN vrednost1
      WHEN uslov2 THEN vrednost2
      ...
      WHEN uslovk THEN vrednostk
      ELSE vrednost
   END

Врши се провера испуњености једног по једног услова и ако је неки од
њих испуњен, вредност израза ``CASE`` је вредност која је придружена
том услову. У супротном је вредност израза ``CASE`` једнака вредности
која је наведена уз ``ELSE``. У нашем примеру, гранање можемо постићи
на следећи начин:

.. code-block:: sql

   SELECT id, CASE
                 WHEN status = 'нерегулисан' THEN 'нерегулисан'
                 ELSE 'регулисан'
              END AS status
   FROM izostanak;

Неки системи за управљање базама података подржавају и функцију облика
``IF(uslov, vrednost_tacno, vrednost_netacno)``. Вредност таквог
израза једнака је вредности ``vrednost_tacno`` ако je услов испуњен
тј. вредности ``vrednost_netacno`` ако услов није испуњен. У Sqlite
ова функција се назива ``IIF``, али пошто постоји само у неким новијим
верзијама, нећемо је користити.

Илуструјмо употребу ``CASE`` израза још једним примером.

.. class:: question

   Уз сваку оцену из табеле оцена приказати и њен текстуални опис
   (недовољан, довољан, добар, врлодобар, одличан).

.. code-block:: sql

   SELECT id, ocena, CASE 
                       WHEN ocena = 1 THEN 'недовољан'
                       WHEN ocena = 2 THEN 'довољан'
                       WHEN ocena = 3 THEN 'добар'
                       WHEN ocena = 4 THEN 'врлодобар'
                       WHEN ocena = 5 THEN 'одличан'
                     END AS opis_ocene
   FROM ocena;

SQL подржава велики број библиотечких функција које су обично детаљно
описане у документацији одабраног система за управљање базама
података. Њихов детаљан опис превазилази домет овог курса.
   
Сортирање (ORDER BY)
--------------------

Често се јавља потреба да податке прикажемо у сортираном редоследу. За
то је упит ``SELECT`` могуће проширити клаузулом ``ORDER BY`` након
које се наводи једна (или више колона) на основу којих се врши
сортирање врста резултата.

.. class:: question

   Приказати имена, презимена и датуме рођења свих ученика одељења
   првог један, уређене неопадајуће по датуму рођења (од најстаријих
   до најмлађих ђака).

   
.. code-block:: sql

   SELECT ime, prezime, datum_rodjenja
   FROM ucenik
   WHERE razred = 1 AND odeljenje = 1
   ORDER BY datum_rodjenja;

Овај упит можемо протумачити као *прочитај име, презиме и датум рођења
из сваке врсте из табеле ученика за које је разред једнак 1 и одељење
једнако 1, сортирајући резултујуће врсте неопадајуће у односу на датум
рођења*.
   
Ако се жели обратан редослед сортирања (нерастући), тада се након
имена колоне може навести ``DESC``. Могуће је навести и ``ASC`` чиме
се наглашава да је редослед неопадајући, међутим, пошто је тај
редослед подразумеван, ово се често изоставља.

.. class:: question

   Приказати имена, презимена и датуме рођења свих ученика одељења
   првог један, уређене нерастући по датуму рођења (од најмлађих
   до најстаријих ђака).

   
.. code-block:: sql

   SELECT ime, prezime, datum_rodjenja
   FROM ucenik
   WHERE razred = 1 AND odeljenje = 1
   ORDER BY datum_rodjenja DESC;

   
Ако је у клаузули ``ORDER BY`` наведено више колона, тада се поређење
врши прво по првој колони, ако су вредности у првој колони једнаке,
поређење се врши по другој колони, ако су вредности и у другој колони
једнаке, поређење се врши по трећој колони итд.

.. class:: question

   Приказати све податке о ученицима у азбучном редоследу презимена и имена.

.. code-block:: sql
   
   SELECT prezime, ime
   FROM ucenik
   ORDER BY prezime ASC, ime ASC;

Пошто су у клаузули ``ORDER BY`` наведене две колоне ``prezime``, па
``ime``, сортирање се прво врши по презименима, а ако су презимена
једнака, онда се врши по именима. ``ASC`` означава да се сортирање обе
колоне врши у неопадајућем редоследу (и може се изоставити).

Ограничавање броја врста резултата (LIMIT)
------------------------------------------

Резултат упита често може бити велика табела, која садржи велики број
редова. Често желимо да прикажемо само део резултата (на пример,
уместо да се у веб-апликацији на једној страници прикажу сви ученици у
школи, могуће је поделити приказ тако да се на свакој страници
приказује само одређен број ученика). У језику SQL то се може постићи
клаузулом ``LIMIT``. Ако се користи у облику ``LIMIT n`` тада се из
резултата издваја само првих ``n`` врста (ако је ``n`` веће од укупног
броја врста резултата упита, не пријављује се грешка, већ се приказује
цео резултат упита).


.. class:: question

   Приказати податке о првих 5 ученика из табеле ученика.

.. code-block:: sql
   
   SELECT *
   FROM ucenik
   LIMIT 5;

Овај упит можемо протумачити као *прочитај највише 5 врста из табеле
ученика*.
   
Ако се користи у облику ``LIMIT start, n`` тада се приказује ``n``
врста, али не са почетка резултујуће табеле, него од позиције
``start``.

.. class:: question

   Приказати податке о наредних 5 ученика из табеле ученика.

.. code-block:: sql
   
   SELECT *
   FROM ucenik
   LIMIT 5, 5;

Овај упит можемо протумачити као *прочитај највише 5 врста из табеле
ученика, прескачући првих 5 врста*.

Ограничавање броја врста резултата се често користи у комбинаcији са
сортирањем. На тај начин је могуће пронаћи врсте које садрже најмањих
или највећих ``n`` вредности колоне по којој се сортира.

.. class:: question

   Приказати податке о пет најмлађих ученика у школи.


.. code-block:: sql

   SELECT *
   FROM ucenik
   ORDER BY datum_rodjenja DESC
   LIMIT 5;

Клаузулом ``ORDER BY datum_rodjenja DESC`` смо захтевали да се све
врсте уреде по датуму рођења, и то опадајући (тако да највећи,
тј. последњи датум рођења буде први), а након тога смо клаузулом
``LIMIT 5`` издвојили само првих 5 врста резултата.

Елиминисање дупликата (DISTINCT)
--------------------------------

У неким случајевима желимо да елиминишемо дупликате из резултата
тј. желимо да добијемо само јединствене вредности унутар неке
колоне. То се постиже навођењем ``DISTINCT`` уз име колоне.

.. class:: question

   Приказати сва различита имена ученика (без понављања).

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik;

Ако бисмо желели да имена буду сортирана по азбучном реду, додали
бисмо клаузулу ``ORDER BY``.

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik
   ORDER BY ime;


.. class:: question

   Приказати све различите датуме у којима ученик са идентификатором 1
   има изостанке.

.. code-block:: sql

   SELECT DISTINCT datum
   FROM izostanak
   WHERE id_ucenik = 1;
   
.. class:: question

   Приказати сва различита женска имена ученица школе. 

.. code-block:: sql

   SELECT DISTINCT ime
   FROM ucenik
   WHERE pol = 'ж';

Агрегатне функције (SUM, AVG, MIN, MAX, COUNT)
----------------------------------------------

У применама је јако често израчунати одређене статистике серија
података. То може бити збир, производ, просек тј. аритметичка средина,
најмања или највећа вредност и слично. Приликом израчунавања ових
статистика од серије елемената (тј. од свих елемената једне колоне
табеле) гради се један резултат тј. сви подаци се агрегирају у
јединствен резултат. Зато се ове функције називају **агрегатне
функције**.

Илуструјмо их све на неколико примера. 

Збир елемената неке колоне се може добити агрегатном функцијом
``SUM``.

.. class:: question
   
   Приказати укупан фонд часова свих предмета.

.. code-block:: sql
                
   SELECT SUM(fond)
   FROM predmet;


Овај упит можемо протумачити као *прочитај збир свих вредности у
колони фонд из свих врста из табеле предмета*.

Примећујемо да за разлику од ранијих упита када је заглавље табеле
садржало имена колона које су наведене након ``SELECT``, овај пут
колона резултата нема неко илустративно име, већ само назив примењене
агрегатне функције. То је могуће променити навођењем тзв. **алијаса**
након кључне речи ``AS``.

.. code-block:: sql
                
   SELECT SUM(fond) AS ukupan_fond
   FROM predmet;


Агрегатне функције се веома често примењују након филтрирања
(рестрикције). За разлику од претходног, за наредним упитом се сасвим
природно може јавити потреба када се рачуна оптерећење ученика.

.. class:: question
   
   Приказати укупан фонд часова предмета из првог разреда.
 
.. code-block:: sql
                
   SELECT SUM(fond)
   FROM predmet
   WHERE razred = 1;

Овај упит можемо протумачити као *прочитај збир свих вредности у
колони фонд из свих врста из табеле предмета код којих је разред
једнак 1*.

Просек (аритметичку средину) елемената неке колоне се може добити
агрегатном функцијом ``AVG``.

.. class:: question

   Приказати просечну оцену из предмета са идентификатором 1
   
.. code-block:: sql

   SELECT AVG(ocena)
   FROM ocena
   WHERE id_predmet = 1;


Најмању вредност у некој колони можемо одредити функцијом ``MIN``, а
највећу функцијом ``MAX``. Ове функције се могу применити и на бројеве
и на ниске и на датуме.
   
.. class:: question

   Приказати најнижу оцену на писменом задатку из математике
   одржаном 18. маја 2021.
   
.. code-block:: sql
                
   SELECT MIN(ocena)
   FROM ocena
   WHERE id_predmet = 1 AND datum = '2021-05-18' AND vrsta = 'писмени задатак';

.. class:: question

   Приказати датум када је у дневник уписана последња оцена из српског
   језика за први разред
   
.. code-block:: sql

   SELECT MAX(datum)
   FROM ocena
   WHERE id_predmet = 2;

Често желимо да одредимо број елемената неке серије. У случају упита
читања података из база то се најчешће своди на то да се изброје врсте
у резултату упита. За то се користи агрегатна функција
``COUNT``. Пошто је број врста у резултату једнак броју елемената
сваке појединачне колоне, обично се уместо назива колоне, као аргумент
ове функције просто наводи звездица ``*``.
   
.. class:: question

   Приказати број ученика у табели ученика.

.. code-block:: sql
                
   SELECT COUNT(*)
   FROM ucenik;

Овај упит можемо протумачимо као *прочитај број свих врста из табеле
ученика*.

Исти резултат би се добио ако би тражило пребројавање елемената било
које конкретне колоне. На пример.

.. code-block:: sql
                
   SELECT COUNT(ime)
   FROM ucenik;

И пребројавање често иде у комбинацији са филтрирањем (рестрикцијом).
   
.. class:: question

   Приказати укупан број предмета у првом разреду
   
.. code-block:: sql

   SELECT COUNT(*)
   FROM predmet
   WHERE razred = 1;

Груписање и израчунавање статистика појединачних група (GROUP BY)
-----------------------------------------------------------------

У претходном поглављу смо видели како се агрегатне функције могу
применити на филтриране податке (податке који задовољавају неки
услов). Видели смо, на пример, како можемо избројати предмете у првом
разреду или како можемо одредити просек свих датих оцена из неког
појединачног предмета. Често се јавља потреба да се иста врста упита
понови за сваку вредност у некој колони. На пример, сасвим је природно
пожелети да се одреди број предмета у сваком од четири разреда или да
се израчуна просечна оцена из сваког појединачног предмета. Уместо да
се прави више сличних упита, овакве статистике је могуће израчунати
коришћењем **груписања и израчунавања статистика по групама**. У
језику SQL се за то користи клаузула ``GROUP BY``.

.. class:: question
   
   Приказати број предмета у сваком од разреда.

.. code-block:: sql

   SELECT razred, COUNT(*) as broj_predmeta
   FROM predmet
   GROUP BY razred;

Приликом извршавања овог упита скуп свих врста у табели предмета
(свака од њих одговара једном предмету) се подели у четири групе које
одговарају сваком од четири разреда, а затим се агрегатна функција
``COUNT`` примени засебно на сваку од те четири групе.


.. class:: question
   
   Приказати најмању оцену из сваког предмета.
   
.. code-block:: sql
                
   SELECT id_predmet, MIN(ocena) as min_ocena
   FROM ocena
   GROUP BY id_predmet;

Груписање је могуће извршити и над више колона.

.. class:: question

   Приказати број ученика у сваком од одељења.

.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_ucenika
   FROM ucenik
   GROUP BY razred, odeljenje;

У овом случају се за сваки пар вредности ``(razred, odeljenje)``
креира посебна група врста и затим се одреди број елемената (врста) у
свакој од тих група.

Груписање и израчунавање статистика по групама је могуће вршити и
након филтрирања (тј. рестрикције).

.. class:: question

   Приказати број девојчица у сваком разреду.
   
.. code-block:: sql
   
   SELECT razred, COUNT(*) as broj_devojcica
   FROM ucenik
   WHERE pol = 'ж'
   GROUP BY razred;

Рестрикција након груписања (HAVING)
....................................

Када се израчунају статистике по групама, можемо пожелети да поново
филтрирамо податке тј. да одаберемо које групе желимо да буду
приказане на основу вредности израчунатих статистика. На пример,
можемо израчунати број ученика у сваком одељењу и затим приказати само
она одељења која имају више од 30 ученика. За то се може користити
клаузула ``HAVING``. Дакле, клаузулу ``WHERE`` користимо да бисмо
извршили филтрирање података пре груписања, а ``HAVING`` након
груписања и израчунавања агрегатних статистика.


.. class:: question

   Приказати одељења у којима има више од 30 ученика.

 
.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_ucenika
   FROM ucenik
   GROUP BY razred, odeljenje
   HAVING broj_ucenika >= 30;


Упит може да садржи двоструко филтрирање (и ``WHERE`` и ``HAVING``).
   
.. class:: question

   Приказати одељења у којима има мање од 5 девојчица.
   
.. code-block:: sql
   
   SELECT razred, odeljenje, COUNT(*) as broj_devojcica
   FROM ucenik
   WHERE pol = 'ж'
   GROUP BY razred, odeljenje
   HAVING broj_devojcica < 5;

Спајање
-------

Сви досадашњи упити су читали податке искључиво из једне табеле. Са
друге стране, организација података у базама је таква да се
информације добијају тако што се подаци читају из више табела
истовремено. Наиме, већ смо видели да смештање свих података у једну
велику табелу доводи до редундантности, неефикасности и повећава
могућност настанка грешака.

.. class:: question

   Приказати све изостанке на дан 14. 5. 2021.         

Први покушај може бити просто читање свих података из табеле изостанака.
   
.. code-block:: sql

   SELECT *
   FROM izostanak
   WHERE datum = '2021-05-14';

Кључни проблем са овим упитом је то што се не виде имена ученика, већ
само њихови идентификатори. Пошто желимо да добијемо што прегледнији
резултат, потребно је да извршимо спајање табеле изостанака и табеле
ученика и то тако што ћемо за сваки идентификатор ученика који је
записан у табели изостанака пронаћи податке о ученику са тим
идентификатором (пре свега његово име и презиме). Један начин да се
споје подаци из две табеле је да се употреби оператор спајања
``... JOIN ... ON ...``.
   
.. code-block:: sql
                
   SELECT *
   FROM izostanak JOIN ucenik ON izostanak.id_ucenik = ucenik.id;

У овом упиту смо извршили спајање табела изостанака и табеле ученика
коришћењем једнакости одговарајућих идентификатора. Резултат ће
садржати све врсте које се добијају тако што се узме по једна врста из
табеле изостанака и из табеле ученика тако да је вредност колоне
``id_ucenik`` у табели изостанака једнака вредности колоне ``id`` у
табели ученика. На пример, претпоставимо да у табели изостанака
постоји врста ``(2, 1, 2021-05-14, 2, неоправдан)``, а у табели
ученика постоји врста ``(1, Петар, Петровић, м, 2007-07-01, 1,
1)``. При том је други број у табели изостанака колона ``id_ucenik``
(идентификатор ученика који је направио изостанак), док је први број у
табели ученик заправо колона ``id`` (идентификатор ученика). Пошто се
у обе те колоне налази вредност 1 (ради се о истом ученику) у спојеној
табели ће постојати врста ``(2, 1, 2021-05-14, 2, неоправдан, 1,
Петар, Петровић, м, 2007-07-01, 1, 1)``.

Приметимо да смо у услову спајања ``ON`` називе колона оквалификовали
називима табела. Што се тиче колоне ``id`` то је било неопходно, јер
колона ``id`` постоји у обе наведене табеле. Са друге стране, колона
``id_ucenik`` постоји само у табели изостанака, па је није било
неопходно наводити назив табеле уз назив колоне, међутим, експлицитним
навођењем имена табеле упит постаје јаснији и прегледнији.

Текст упита се може мало скратити ако се табелама привремено дају
нова, краћа имена, навођењем **алијаса**.

.. code-block:: sql
                
   SELECT *
   FROM izostanak AS i
        JOIN ucenik AS u ON i.id_ucenik = u.id;

Кључна реч ``AS`` се у овом случају може изоставити (``FROM izostanak
i JOIN ucenik u ON ...``).
   
Спојене табеле се могу филтрирати (коришћењем клаузуле ``WHERE``) и
могуће је резултат пројектовати само на оне колоне које нас
занимају. Напоменимо да се филтрирање, ефикасности ради, врши пре
спајања.

.. code-block:: sql
                
   SELECT ime, prezime, cas, status
   FROM izostanak i
        JOIN ucenik u ON i.id_ucenik = u.id
   WHERE datum = '2021-05-14';

Још један начин да се спајање табела изврши је тзв. **имплицитно
спајање**. Наиме, ако се након ``FROM`` наведе више табела раздвојених
зарезима, израчунава се њихов **Декартов производ** тј. свака врста
прве табеле се комбинује (надовезује) са сваком врстом друге табеле.
На пример,

.. code-block:: sql
                
   SELECT *
   FROM izostanak, ucenik;

Од свих ових врста, нама су релевантне само оне у којима је
идентификатор ученика из табеле изостанака једнак идентификатору из
табеле ученика и њих можемо издвојити клаузулом ``WHERE``.


.. code-block:: sql
                
   SELECT *
   FROM izostanak i, ucenik u
   WHERE i.id_ucenik = u.id;

Наравно, могуће је навести и додатан услов у ком се ограничавамо само
на жељени датум.


.. code-block:: sql
                
   SELECT *
   FROM izostanak i, ucenik u
   WHERE i.id_ucenik = u.id AND datum = '2021-05-14';

Ипак, експлицитно спајање је пожељније користити од имплицитног (упити
су јаснији, а на неким системима за управање базама података могу бити
и ефикаснији).

.. class:: question
                
   Приказати све оцене из математике за први разред.

Главни проблем приликом реализације овог упита је то што не знамо
идентификатор тог предмета. Оцене се налазе у табели оцена, док се
идентификатори предмета налазе у табели предмета и једно могуће решење
је да се прво изврши спајање те две табеле, да би се затим филтирање
могло вршити на основу назива предмета и разреда у ком се предаје
(који су нам познати) уместо на основу идентификатора предмета који
нам је непознат (претпоставићемо да постоји само један предмет у првом
разреду који се зове математика тј. да ако постоји више таквих
предмета да ћемо приказивати оцене из свих тих предмета).

.. code-block:: sql

   SELECT id_ucenik, ocena, datum, vrsta
   FROM ocena
        JOIN predmet ON ocena.id_predmet = predmet.id
   WHERE predmet.naziv = 'Математика' AND predmet.razred = 1;

   
Спајање је могуће применити и на више табела.

.. class:: question
           
   Приказати све оцене у читљивом формату (тако да се виде име и
   презиме ученика и назив предмета)

.. code-block:: sql

   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id;

Наравно, и тада је могуће извршити додатно филтрирање коришћењем
клаузуле ``WHERE``.

.. class:: question

   Приказати све оцене на писменим задацима из предмета првог разреда
   у читљивом формату.

.. code-block:: sql
                
   SELECT p.naziv, u.ime, u.prezime, o.ocena, o.datum, o.vrsta
   FROM ocena o
        JOIN predmet p ON o.id_predmet = p.id
        JOIN ucenik u ON o.id_ucenik = u.id
   WHERE p.razred = 1 AND vrsta = 'писмени задатак';

Табеле при спајању не морају бити различите -- могуће је спојити
табелу саму са собом.

.. class:: question

   Приказати све парове близанаца (под близанцима ћемо подразумевати
   све парове ученика који се исто презивају и имају исти датум
   рођења).

Први покушај подразумева само да се табела ``ucenik`` споји сама са
собом, уз услов да презиме и датум рођења буду једнаки.

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime;

Као што видимо, постоје два проблема са овим приступом. Наиме, сваки
ученик има исти датум рођења и презиме као он сам, па се за сваког
ученика пријављује да је сам себи близанац. Даље, сваки пар близанаца
се пријављује два пута (јер се за првог близанца успешно налази пар,
па се затим и за другог близанца успешно налази пар). И један и други
проблем се могу решити ако се наметне да су идентификатори унутар пара
близанаца различити (тиме се елиминише могућност да је неко сам себи
близанац) и уређени у неком редоследу (тиме се елиминише двоструко
пријављивање истих парова близанаца).

.. code-block:: sql

   SELECT u1.ime as ime1, u2.ime as ime2, u1.prezime
   FROM ucenik as u1
        JOIN ucenik as u2 ON u1.datum_rodjenja = u2.datum_rodjenja AND u1.prezime = u2.prezime
   WHERE u1.id < u2.id;
   
**Ко жели да зна више?** У базама података постоји неколико различитих
оператора спајања: ``INNER JOIN``, ``CROSS JOIN``, ``LEFT JOIN``,
``RIGHT JOIN``, ``FULL JOIN`` који се углавном разликују по томе шта
се дешава када у једној од спојених табела не постоји врста која би
требало да се споји. Оператор ``JOIN`` који смо приказали је заправо
оператор ``INNER JOIN`` (тзв. унутрашње спајање). То је најчешће
коришћена врста спајања, па се стога назнака о којој врсти спајања је
реч може изоставити.

Природно је очекивати да се у табели изостанака налазе само они
идентификатори ученика за које у табели ученика постоје одговарајући
подаци. То је осигурано постављањем *страног кључа* између колоне
``id_ucenik`` у табели изостанака и колоне ``id`` у табели ученика.

Међутим, сасвим је могуће да се вредност колоне ``id`` из неких редова 
табеле ученика уопште не појављује у колони ``id_ucenik`` у 
табели изостанака (јер могу да постоје ученици који немају ниједан 
изостанак). Размотримо тада следећи задатак.

.. class:: question

   Приказати списак свих ученика са њиховим изостанцима.

Ако бисмо извршили обично (унутрашње) спајање табеле ученика и табеле
изостанака, добили бисмо податке само о оним ученицима који имају
изостанке.


.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        JOIN izostanak i ON u.id = i.id_ucenik;

Ако желимо да се прикажу подаци и о ученицима који немају изостанке,
потребно је да применимо тзв. лево спољашње спајање које се постиже
оператором ``LEFT OUTER JOIN`` или скраћено ``LEFT JOIN``.


.. code-block:: sql
                
   SELECT *
   FROM ucenik u
        LEFT JOIN izostanak i ON u.id = i.id_ucenik;

Код ученика који имају изостанака, за сваки изостанак постоји
одговарајућа врста у резултату. Код ученика који немају изостанака у
пољима који описују изостанак стоје специјалне **недостајуће
вредности** (``NULL``).

Детаљније изучавање разних врста спајања превазилази градиво овог
предмета и тиме се нећемо бавити у наставку.


Спајање и груписање
...................

   
.. class:: question
                
   Приказати просечне оцене из свих предмета из првог разреда.

Јасно је да је потребно извршити груписање оцена из табеле оцена на
основу предмета (тј. њихових идентификатора) и затим израчунати
статистику (аритметичку средину) за сваку групу посебно. Проблем је то
што се захтева филтрирање предмета тако да се прикажу само просечне
оцене за предмете из првог разреда, међутим, подаци о разреду у ком се
предмет предаје се не налази у табели оцена, већ у табели
предмета. Стога је пре класичног груписања и израчунавања статистика
по групама потребно спојити табелу оцена и табелу предмета.
   
.. code-block:: sql

   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet on ocena.id_predmet = predmet.id
   WHERE razred = 1
   GROUP BY predmet.id;

.. class:: question

   Приказати просечне оцене из свих предмета (уређене опадајуће по
   просечној оцени).

Овај упит је сличан претходном. Када бисмо се задовољили приказом
просечних оцена и идентификатора предмета, тада бисмо могли применити
само груписање и израчунавање просека група из табеле са
оценама. Међутим, пошто желимо да прикажемо називе предмета, а подаци
о њима се налазе у табели предмета, вршимо спајање две табеле.
   
.. code-block:: sql
                
   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet on ocena.id_predmet = predmet.id
   GROUP BY predmet.id
   ORDER BY prosek DESC;

Могуће је користити и клаузулу ``HAVING`` (подсетимо се, она служи за
филтрирање након груписања на основу израчунатих вредности статистика
група).
   
.. class:: question
   
   Приказати називе предмета и просечне оцене на писменим задацима за
   све предмете код којих је просечна оцена на писменим задацима бар
   3.50.

.. code-block:: sql
                
   SELECT naziv, AVG(ocena) AS prosek
   FROM ocena
        JOIN predmet ON ocena.id_predmet = predmet.id
   WHERE ocena.vrsta = 'писмени задатак'
   GROUP BY predmet.id
   HAVING prosek >= 3.50;

   
Угнежђени упити
---------------

Код сложенијих упита може бити корисно да се упит формира тако да се
до резултата долази кроз неколико фаза. Свака фаза се формулише као
нови ``SELECT`` упит који поред полазних табела може да користи и
резултат упита из претходне фазе.

Прикажимо ово кроз неколико примера.

.. class:: question
           
   Приказати највећи број остварених оправданих изостанака неког
   ученика.

У првој фази ћемо формулисати упит који за сваког ученика израчунава
број оправданих изостанака. Ово је класичан упит у ком се врши
груписање и израчунавање статистика (овај пут броја елемената сваке
групе).
   
.. code-block:: sql

   SELECT COUNT(*) AS broj
   FROM izostanak
   WHERE status = 'оправдан'
   GROUP BY id_ucenik

Коначан резултат можемо добити тако што из табеле која се добија као
резултат претходног упита израчуна максимална вредност колоне
``broj``. То се лако постиже коришћењем агрегатне функције ``MAX``.
   
.. code-block:: sql
                
   SELECT MAX(broj)
   FROM
       (SELECT COUNT(*) AS broj
        FROM izostanak
        WHERE status = 'оправдан'
        GROUP BY id_ucenik);


.. class:: question
           
   Приказати просечне оцене свих предмета који се предају у првом
   разреду.

Овај задатак се може решити спајањем (и то је пожељно решење, поготово
ако се жели приказ назива предмета). Могуће је и решење засновано на
угнежђеним упитима тако што се у првој фази из табеле предмета издвоје
идентификатори предмета који се предају у првом разреду, а онда се тај
скуп идентификатора у другој фази употреби за издвајање одговарајућих
оцена из табеле оцена, пре груписања и рачунања статистика по групама.
   
        
.. code-block:: sql
        
   SELECT id_predmet, AVG(ocena) AS prosek
   FROM ocena
   WHERE id_predmet IN (SELECT id
                        FROM predmet
                        WHERE razred = 1)
   GROUP BY id_predmet;

.. class:: question
           
   Приказати називе предмета и просечне оцене на писменим задацима за
   све предмете код којих је просечна оцена на писменим задацима бар
   3,50.

Када бисмо се задовољили само приказом идентификатора предмета, онда
бисмо све могли да решимо упитом над табелом оцена, груписањем на
основу идентификатора предмета, израчунавањем просека оцена за сваку
групу и затим рестрикцијом на оне предмете код којих је просечна оцена
већа од 3,5. Пошто су нам потребни називи предмета, можемо извршити
спајање овако добијеног резултата упита са табелом предмета у којој се
налазе идентификатори и називи предмета.
   
.. code-block:: sql
                
   SELECT naziv, prosek
   FROM predmet
        JOIN (SELECT id_predmet, AVG(ocena) AS prosek
              FROM ocena
              WHERE ocena.vrsta = 'писмени задатак'
              GROUP BY id_predmet
              HAVING prosek >= 3.50)
          ON predmet.id = id_predmet;

          
.. class:: question
           
   За свако одељење приказати највећи број оправданих изостанака.

У првој фази можемо изградити табелу која за сваког ученика садаржи
идентификатор, разред и одељење и број оправданих изостанака. Пошто се
разред и одељење налазе у табели ученика, а број изостанака се рачуна
на основу података у табели изостанака, прво вршимо спајање те две
табеле, вршимо рестрикцију само на оправдане изостанек, а након тога
групишемо податке на основу идентификатора ученика и применом
``COUNT(*)`` одређујемо број оправданих изостанака.

.. code-block:: sql

   SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
   FROM izostanak
        JOIN ucenik on izostanak.id_ucenik = ucenik.id
   WHERE status = 'оправдан'
   GROUP BY ucenik.id

Када је у првој фази одређена оваква помоћна табела, тада у другој
фази лако можемо одредити максимални број оправданих изостанака за
свако одељење (груписањем на основу разреда и одељења и применом
агрегатне функције ``MAX``).
   
.. code-block:: sql
                
   SELECT razred, odeljenje, MAX(broj_opravdanih)
   FROM (SELECT ucenik.id, razred, odeljenje, COUNT(*) as broj_opravdanih
         FROM izostanak
              JOIN ucenik on izostanak.id_ucenik = ucenik.id
         WHERE status = 'оправдан'
         GROUP BY ucenik.id)
   GROUP BY razred, odeljenje;

Приметимо да табела добијена као резултат угнежђеног подупита нема
назив. Ако је потребно да јој дамо назив, то се може урадити навођењем
**алијаса**, коришћењем кључне речи ``AS`` (у облику ``FROM (SELECT
...) AS naziv``). Алијасе смо раније користили за именовање колона,
док се овај пут именује табела.
   
Сви приказани угнежђени подупити до сада су били такви да се унутрашњи
упит (тзв. подупит) може извршити независно од спољашњег. Међутим, SQL
допушта и да се у унутрашњем упиту врши филтрирање на основу вредности
наведене у спољашњем подупиту. У том случају кажемо да су упити
**корелисани**.

.. class:: question
           
   Приказати податке о изостанцима ученика који се зову Петар.

Овај упит се природно може написати коришћењем спајања табела ученика
и изостанака. Ипак, приказаћемо решење које користи корелисани
подупит. У спољашњем упиту читамо податке из табеле изостанака, а у
подупиту читамо име ученика чији идентификатор одговара идентификатору
у текућој врсти прочитаној из табеле изостанака и онда изостанке
филтрирамо на основу тога да ли је тако добијено име једнако
``Петар``.
   
.. code-block:: sql

   SELECT *
   FROM izostanak i
   WHERE 'Петар' = (SELECT ime
                    FROM ucenik u
                    WHERE u.id = i.id_ucenik);

   
Провера постојања (EXISTS)
--------------------------

Некада желимо да издвојимо само оне врсте за које корелисани подупит
враћа непразну (или празну) табелу тј. ако се утврди да постоји (или
да не постоји) нека врста која задовољава услов корелисаног подупита.
За то се може користити услов ``EXISTS`` (или ``NOT EXISTS``, који је
заправо само негација услова ``EXISTS``).

.. class:: question

   Приказати имена ученика који имају неоправдане изостанке.
   
.. code-block:: sql
                
   SELECT id, ime, prezime
   FROM ucenik
   WHERE EXISTS (SELECT *
                 FROM izostanak
                 WHERE izostanak.id_ucenik = ucenik.id AND status = 'неоправдан');

Наравно, постоје и други начини да се овај упит реализује. На пример,
можемо спојити табелу ученика и табелу изостанака, груписати изостанке
по свим ученицима, и приказати имена и презимена за сваку групу
(приметимо да овде не примењујемо ни једну агрегатну функцију на
формиране групе).

.. code-block:: sql

   SELECT ucenik.id, ime, prezime
   FROM ucenik JOIN
        izostanak on izostanak.id_ucenik = ucenik.id
   WHERE status = 'неоправдан'
   GROUP BY ucenik.id;
                
У наредном проблему, можемо искористити услов непостојања ``NOT
EXISTS``.
                 
.. class:: question
           
   Приказати имена ученика који немају нерегулисаних изостанака.
   
.. code-block:: sql
                
   SELECT id, ime, prezime
   FROM ucenik
   WHERE NOT EXISTS (SELECT *
                     FROM izostanak
                     WHERE izostanak.id_ucenik = ucenik.id AND status = 'нерегулисан');
